<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Gemini programmingéšŠã«ã‚ˆã‚‹WebAssembly (Wasm) ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã€‚Rustã‚³ãƒ¼ãƒ‰ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã§å®Ÿè¡Œå¯èƒ½å½¢å¼ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚">
    <meta name="keywords" content="Wasm, WebAssembly, Rust, ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©, Vercel, Render, Gemini">
    <meta name="author" content="ã‚«ã‚«ã‚ªãƒãƒ¡">
    <meta property="og:title" content="Gemini Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©">
    <meta property="og:description" content="Rustã‚³ãƒ¼ãƒ‰ã‚’WebAssemblyã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€Webã§å®Ÿè¡Œã—ã¾ã™ã€‚">
    <meta property="og:image" content="https://kakaomames.github.io/rei/logo.png">
    <meta property="og:url" content="https://xeroxapp032.vercel.app/wasm2">
    <link rel="icon" href="https://kakaomames.github.io/rei/logo.png" type="image/png">
    <title>Gemini programmingéšŠ Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { font-family: 'Arial', sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); }
        h1 { text-align: center; color: #333; }
        textarea { width: 100%; height: 250px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; }
        button { padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #status-area { margin-top: 20px; padding: 15px; border-radius: 4px; background-color: #e9ecef; }
        #output-area { margin-top: 20px; padding: 15px; border: 1px dashed #333; background-color: #fff; min-height: 50px; }
        .logo { display: block; margin: 0 auto 10px; width: 50px; }
        .error { color: #dc3545; font-weight: bold; }
        .success { color: #28a745; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://kakaomames.github.io/rei/logo.png" alt="Gemini Logo" class="logo">
        <h1>Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© ğŸ¦€âš™ï¸</h1>
        <p>Rustã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã€ã€Œalertã€é–¢æ•°ã‚’å‘¼ã³å‡ºã™ Wasm ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ‰ã¯ `greet()` ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</p>

        <textarea id="rust-code">// Rustã‚³ãƒ¼ãƒ‰ã¯ wasm-bindgen ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    // JavaScriptã® 'alert' é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    fn alert(s: &str);
}

// Rustã®é–¢æ•°ã‚’ JavaScript ã«å…¬é–‹
#[wasm_bindgen]
pub fn greet() {
    alert("Hello from Rust/Wasm! (Generated ZIP file will contain this Wasm)");
}

// Cargo.tomlã®ä¾å­˜é–¢ä¿‚:
// wasm-bindgen = "0.2.92"</textarea>
        
        <button id="compile-button">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é–‹å§‹ & ZIPç”Ÿæˆ</button>

        <div id="status-area">
            <h3>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="compile-status">æº–å‚™å®Œäº†</span></h3>
            <p>é€²æ—: <span id="compile-progress">0%</span></p>
            <p id="status-message">ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>
        </div>

        <div id="output-area">
            <h3>çµæœ</h3>
            <p id="execution-message">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æˆåŠŸå¾Œã€ZIPãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚</p>
        </div>
    </div>

    <script>
        // --- è¨­å®šã¨å®šæ•° ---
        const COMPILER_URL = '/api/compile';
        const STATUS_URL = '/api/status/';
        const POLLING_INTERVAL = 5000; // 5ç§’ã”ã¨ã«ãƒãƒ¼ãƒªãƒ³ã‚°
        
        // --- DOMè¦ç´  ---
        const compileButton = document.getElementById('compile-button');
        const rustCodeArea = document.getElementById('rust-code');
        const compileStatus = document.getElementById('compile-status');
        const compileProgress = document.getElementById('compile-progress');
        const statusMessage = document.getElementById('status-message');
        const executionMessage = document.getElementById('execution-message');
        
        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
        let isCompiling = false;

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        compileButton.addEventListener('click', () => {
            if (!isCompiling) {
                startCompilation(rustCodeArea.value);
            }
        });

        // --- ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ ---

        async function startCompilation(rustCode) {
            isCompiling = true;
            compileButton.disabled = true;
            updateStatus('ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...', 0, 'åˆæœŸãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’Vercelã«é€ä¿¡ã—ã¦ã„ã¾ã™ã€‚');
            executionMessage.textContent = 'çµæœå¾…ã¡...';

            try {
                // 1. Vercelã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¿ã‚¹ã‚¯ã‚’ä¾é ¼
                let response = await fetch(COMPILER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: rustCode })
                });

                if (response.status === 202) {
                    const data = await response.json();
                    const taskId = data.task_id;
                    console.log(`Task submitted. ID: ${taskId}. Starting polling.`);
                    
                    // 2. ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’é–‹å§‹
                    await pollForStatus(taskId);

                } else {
                    const errorData = await response.json().catch(() => ({ message: 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼' }));
                    throw new Error(`ã‚¿ã‚¹ã‚¯é–‹å§‹å¤±æ•— (${response.status}): ${errorData.message}`);
                }

            } catch (error) {
                updateStatus('ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¤±æ•—', 0, `ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
            } finally {
                isCompiling = false;
                compileButton.disabled = false;
            }
        }

        async function pollForStatus(taskId) {
            return new Promise((resolve, reject) => {
                const intervalId = setInterval(async () => {
                    try {
                        const statusResponse = await fetch(STATUS_URL + taskId);
                        const statusData = await statusResponse.json();

                        updateStatus('ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸­', statusData.progress, statusData.message);

                        if (statusData.status === 'completed') {
                            clearInterval(intervalId);
                            updateStatus('å®Œäº†', 100, 'Wasmã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«æˆåŠŸã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­ã§ã™...');
                            await handleSuccessfulCompilation(statusData); // â˜…ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã«å‡¦ç†ã‚’å§”è­²â˜…
                            resolve();

                        } else if (statusData.status === 'error') {
                            clearInterval(intervalId);
                            const errMsg = statusData.message || "Renderã‚µãƒ¼ãƒãƒ¼ã§äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚";
                            updateStatus('ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¤±æ•—', statusData.progress, errMsg, true);
                            reject(new Error(errMsg));

                        } else {
                            // å‡¦ç†ä¸­ (in_progress) ã®ã¾ã¾ç¶™ç¶š
                        }
                    } catch (error) {
                        clearInterval(intervalId);
                        updateStatus('ãƒãƒ¼ãƒªãƒ³ã‚°å¤±æ•—', 0, `ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
                        reject(error);
                    }
                }, POLLING_INTERVAL);
            });
        }

        // --- ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ­ã‚¸ãƒƒã‚¯ ---

        /**
         * æˆåŠŸã—ãŸã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã€ZIPåŒ–ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã›ã‚‹
         */
        async function handleSuccessfulCompilation(data) {
            try {
                const wasmBinary = base64ToArrayBuffer(data.wasm_base64);
                
                // wasm-bindgenã®JSã‚³ãƒ¼ãƒ‰ã¯ 'wasm_project_bg.wasm' ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã€
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã“ã‚Œã«åˆã‚ã›ã‚‹ã‹ã€JSã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãæ›ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
                // éšŠå“¡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€šã‚Šã€wasmãƒ•ã‚¡ã‚¤ãƒ«åã¯ 'wasm.wasm' ã¨ã—ã€
                // index.htmã®JSã‚³ãƒ¼ãƒ‰ã§wasm.wasmã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¾ã™ã€‚
                
                // wasm-bindgenã®ç”Ÿæˆã™ã‚‹JSã‚³ãƒ¼ãƒ‰å†…ã® Wasm ãƒ•ã‚¡ã‚¤ãƒ«åå‚ç…§ã‚’ 'wasm_project_bg.wasm' ã‹ã‚‰ 'wasm.wasm' ã«ç½®æ›
                let jsCode = data.js_code.replace(/wasm_project_bg\.wasm/g, 'wasm.wasm');


                // 1. ZIPã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ– (JSZipãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ã§åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’å‰æ)
                const zip = new JSZip();
                
                // 2. Wasmãƒ•ã‚¡ã‚¤ãƒ« (wasm.wasm) ã®è¿½åŠ  (ArrayBufferã¨ã—ã¦)
                zip.file("wasm.wasm", wasmBinary, { binary: true });
                
                // 3. JSã‚°ãƒ«ãƒ¼ã‚³ãƒ¼ãƒ‰ (script.js) ã®è¿½åŠ 
                zip.file("script.js", jsCode);
                
                // 4. HTMLãƒ•ã‚¡ã‚¤ãƒ« (index.htm) ã®ä½œæˆã¨è¿½åŠ 
                const indexHtmlContent = createIndexHtml();
                zip.file("index.htm", indexHtmlContent);

                // 5. ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
                updateStatus('å®Œäº†', 100, 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...', false);
                const zipBlob = await zip.generateAsync({ type: "blob" });

                // 6. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®å®Ÿè¡Œ
                const downloadUrl = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = 'wasm_project.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl); // URLã‚’è§£æ”¾

                updateStatus('å®Œäº†', 100, 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚', false);
                executionMessage.className = 'success';
                executionMessage.textContent = 'ğŸ‰ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ç¾¤ (index.htm, script.js, wasm.wasm) ãŒZIPãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸã€‚';

            } catch (e) {
                updateStatus('ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆå¤±æ•—', 100, `ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã¾ãŸã¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`, true);
                executionMessage.className = 'error';
                executionMessage.textContent = `ã‚¨ãƒ©ãƒ¼: ${e.message}`;
                console.error("File generation error:", e);
            }
        }

        /**
         * Wasmã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€greet()ã‚’å®Ÿè¡Œã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª index.htm ã®å†…å®¹ã‚’ç”Ÿæˆ
         */
        function createIndexHtml() {
            // script.js (ES Module) ã‹ã‚‰ init ã¨ greet ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã€wasm.wasmã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦å®Ÿè¡Œã™ã‚‹HTML
            return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Wasm å®Ÿè¡Œçµæœ</title>
</head>
<body>
    <h1>Wasm å®Ÿè¡Œçµæœ</h1>
    <p>ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’é–‹ã„ã¦ãã ã•ã„ã€‚Wasmã§å®šç¾©ã•ã‚ŒãŸ 'alert' ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

    <script type="module">
        // wasm-bindgenãŒç”Ÿæˆã—ãŸã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import init, { greet } from './script.js';

        async function run() {
            try {
                // init() ã« Wasm ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ (ã“ã“ã§ã¯ './wasm.wasm') ã‚’æ¸¡ã™ã“ã¨ã§ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹
                // script.js å†…ã®å‚ç…§ã‚’ 'wasm.wasm' ã«ç½®æ›æ¸ˆã¿ãªã®ã§ã€ã“ã“ã§ãƒ‘ã‚¹æŒ‡å®šã¯ä¸è¦
                await init(); 
                
                // Wasmã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚’å®Ÿè¡Œ (Rustå´ã®alertãŒå®Ÿè¡Œã•ã‚Œã‚‹)
                greet();

            } catch (e) {
                console.error("Wasmã®ãƒ­ãƒ¼ãƒ‰ã¾ãŸã¯å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ:", e);
                alert("Wasmã®ãƒ­ãƒ¼ãƒ‰ã¾ãŸã¯å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
            }
        }
        run();
    </script>
</body>
</html>`;
        }


        // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---

        function updateStatus(status, progress, message, isError = false) {
            compileStatus.textContent = status;
            compileProgress.textContent = `${progress}%`;
            statusMessage.textContent = message;
            statusMessage.className = isError ? 'error' : '';
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

    </script>
</body>
</html>
