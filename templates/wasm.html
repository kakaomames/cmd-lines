<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Gemini programmingéšŠã«ã‚ˆã‚‹WebAssembly (Wasm) ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã€‚Rustã‚³ãƒ¼ãƒ‰ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã§å®Ÿè¡Œå¯èƒ½å½¢å¼ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚">
    <meta name="keywords" content="Wasm, WebAssembly, Rust, ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©, Vercel, Render, Gemini">
    <meta name="author" content="ã‚«ã‚«ã‚ªãƒãƒ¡">
    <meta property="og:title" content="Gemini Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©">
    <meta property="og:description" content="Rustã‚³ãƒ¼ãƒ‰ã‚’WebAssemblyã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€Webã§å®Ÿè¡Œã—ã¾ã™ã€‚">
    <meta property="og:image" content="https://kakaomames.github.io/rei/logo.png">
    <meta property="og:url" content="https://xeroxapp032.vercel.app/wasm2">
    <link rel="icon" href="https://kakaomames.github.io/rei/logo.png" type="image/png">
    <title>Gemini programmingéšŠ Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); }
        h1 { text-align: center; color: #333; }
        textarea { width: 100%; height: 250px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; }
        button { padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #status-area { margin-top: 20px; padding: 15px; border-radius: 4px; background-color: #e9ecef; }
        #output-area { margin-top: 20px; padding: 15px; border: 1px dashed #333; background-color: #fff; min-height: 50px; }
        .logo { display: block; margin: 0 auto 10px; width: 50px; }
        .error { color: #dc3545; font-weight: bold; }
        .success { color: #28a745; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://kakaomames.github.io/rei/logo.png" alt="Gemini Logo" class="logo">
        <h1>Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© ğŸ¦€âš™ï¸</h1>
        <p>Rustã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã€ã€Œalertã€é–¢æ•°ã‚’å‘¼ã³å‡ºã™ Wasm ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ‰ã¯ `greet()` ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</p>

        <textarea id="rust-code">// Rustã‚³ãƒ¼ãƒ‰ã¯ wasm-bindgen ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    // JavaScriptã® alert é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    fn alert(s: &str);
}

// Rustã®é–¢æ•°ã‚’ JavaScript ã«å…¬é–‹
#[wasm_bindgen]
pub fn greet() {
    alert("Hello from Rust/Wasm!");
}

// Cargo.tomlã®ä¾å­˜é–¢ä¿‚:
// wasm-bindgen = "0.2.92"</textarea>
        
        <button id="compile-button">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é–‹å§‹</button>

        <div id="status-area">
            <h3>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="compile-status">æº–å‚™å®Œäº†</span></h3>
            <p>é€²æ—: <span id="compile-progress">0%</span></p>
            <p id="status-message">ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>
        </div>

        <div id="output-area">
            <h3>å®Ÿè¡Œçµæœ</h3>
            <p id="execution-message">Wasmã®ãƒ­ãƒ¼ãƒ‰ã¨å®Ÿè¡Œã«æˆåŠŸã™ã‚‹ã¨ã€ã“ã“ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
        </div>
    </div>

    <script>
        // --- è¨­å®šã¨å®šæ•° ---
        const COMPILER_URL = '/api/compile';
        const STATUS_URL = '/api/status/';
        const POLLING_INTERVAL = 5000; // 5ç§’ã”ã¨ã«ãƒãƒ¼ãƒªãƒ³ã‚°
        
        // --- DOMè¦ç´  ---
        const compileButton = document.getElementById('compile-button');
        const rustCodeArea = document.getElementById('rust-code');
        const compileStatus = document.getElementById('compile-status');
        const compileProgress = document.getElementById('compile-progress');
        const statusMessage = document.getElementById('status-message');
        const executionMessage = document.getElementById('execution-message');
        
        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
        let isCompiling = false;

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        compileButton.addEventListener('click', () => {
            if (!isCompiling) {
                startCompilation(rustCodeArea.value);
            }
        });

        // --- ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ ---

        /**
         * ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¿ã‚¹ã‚¯ã‚’é–‹å§‹ã—ã€ã‚¿ã‚¹ã‚¯IDã‚’å–å¾—å¾Œãƒãƒ¼ãƒªãƒ³ã‚°ã‚’é–‹å§‹
         * @param {string} rustCode - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå…¥åŠ›ã—ãŸRustã‚³ãƒ¼ãƒ‰
         */
        async function startCompilation(rustCode) {
            isCompiling = true;
            compileButton.disabled = true;
            updateStatus('ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...', 0, 'åˆæœŸãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’Vercelã«é€ä¿¡ã—ã¦ã„ã¾ã™ã€‚');
            executionMessage.textContent = 'çµæœå¾…ã¡...';

            try {
                // 1. Vercelã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¿ã‚¹ã‚¯ã‚’ä¾é ¼
                let response = await fetch(COMPILER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: rustCode })
                });

                if (response.status === 202) {
                    const data = await response.json();
                    const taskId = data.task_id;
                    console.log(`Task submitted. ID: ${taskId}. Starting polling.`);
                    
                    // 2. ãƒãƒ¼ãƒªãƒ³ã‚°ã‚’é–‹å§‹
                    await pollForStatus(taskId);

                } else {
                    const errorData = await response.json().catch(() => ({ message: 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼' }));
                    throw new Error(`ã‚¿ã‚¹ã‚¯é–‹å§‹å¤±æ•— (${response.status}): ${errorData.message}`);
                }

            } catch (error) {
                updateStatus('ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¤±æ•—', 0, `ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
            } finally {
                isCompiling = false;
                compileButton.disabled = false;
            }
        }

        /**
         * Renderã‹ã‚‰ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒå®Œäº†ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã¾ã§å†å¸°çš„ã«å•ã„åˆã‚ã›ã‚‹
         * @param {string} taskId - å•ã„åˆã‚ã›ã‚‹ã‚¿ã‚¹ã‚¯ID
         */
        async function pollForStatus(taskId) {
            return new Promise((resolve, reject) => {
                const intervalId = setInterval(async () => {
                    try {
                        const statusResponse = await fetch(STATUS_URL + taskId);
                        const statusData = await statusResponse.json();

                        updateStatus('ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸­', statusData.progress, statusData.message);

                        if (statusData.status === 'completed') {
                            clearInterval(intervalId);
                            updateStatus('å®Œäº†', 100, 'Wasmã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«æˆåŠŸã—ã¾ã—ãŸã€‚å®Ÿè¡Œæº–å‚™ä¸­...');
                            await handleSuccessfulCompilation(statusData);
                            resolve();

                        } else if (statusData.status === 'error') {
                            clearInterval(intervalId);
                            const errMsg = statusData.message || "Renderã‚µãƒ¼ãƒãƒ¼ã§äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚";
                            updateStatus('ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¤±æ•—', statusData.progress, errMsg, true);
                            reject(new Error(errMsg));

                        } else {
                            // å‡¦ç†ä¸­ (in_progress) ã®ã¾ã¾ç¶™ç¶š
                        }
                    } catch (error) {
                        clearInterval(intervalId);
                        updateStatus('ãƒãƒ¼ãƒªãƒ³ã‚°å¤±æ•—', 0, `ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
                        reject(error);
                    }
                }, POLLING_INTERVAL);
            });
        }

        // --- å®Ÿè¡Œã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---

        /**
         * æˆåŠŸã—ãŸWasmãƒã‚¤ãƒŠãƒªã¨JSã‚³ãƒ¼ãƒ‰ã‚’ãƒ­ãƒ¼ãƒ‰ãƒ»å®Ÿè¡Œã™ã‚‹
         * @param {object} data - æˆåŠŸå¿œç­”ã®JSONãƒ‡ãƒ¼ã‚¿
         */
        async function handleSuccessfulCompilation(data) {
            try {
                const wasmBinary = base64ToArrayBuffer(data.wasm_base64);
                const jsCode = data.js_code;

                // JSã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã€Wasmã‚’ãƒ­ãƒ¼ãƒ‰ãƒ»ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
                const initModule = await instantiateWasm(wasmBinary, jsCode);
                
                // wasm-bindgen ã«ã‚ˆã£ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸé–¢æ•°ã‚’å®Ÿè¡Œ
                if (initModule && typeof initModule.greet === 'function') {
                    initModule.greet(); // alertãŒå‘¼ã°ã‚Œã‚‹
                    executionMessage.className = 'success';
                    executionMessage.textContent = 'Wasmã®ãƒ­ãƒ¼ãƒ‰ã¨å®Ÿè¡Œã«æˆåŠŸã—ã¾ã—ãŸã€‚alert()é–¢æ•°ãŒå‘¼ã°ã‚ŒãŸã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                } else {
                    executionMessage.className = 'error';
                    executionMessage.textContent = 'Wasmã®ãƒ­ãƒ¼ãƒ‰ã¯æˆåŠŸã—ã¾ã—ãŸãŒã€ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸ `greet` é–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚';
                }
            } catch (e) {
                executionMessage.className = 'error';
                executionMessage.textContent = `Wasmå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${e.message}`;
                console.error("Wasm execution error:", e);
            }
        }

        /**
         * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹
         * @param {string} status - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆ
         * @param {number} progress - é€²æ—ç‡ (0-100)
         * @param {string} message - è©³ç´°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
         * @param {boolean} isError - ã‚¨ãƒ©ãƒ¼ãƒ•ãƒ©ã‚°
         */
        function updateStatus(status, progress, message, isError = false) {
            compileStatus.textContent = status;
            compileProgress.textContent = `${progress}%`;
            statusMessage.textContent = message;
            statusMessage.className = isError ? 'error' : '';
        }

        /**
         * Base64æ–‡å­—åˆ—ã‚’ArrayBufferã«å¤‰æ›ã™ã‚‹
         * @param {string} base64 - Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸWasmãƒ‡ãƒ¼ã‚¿
         * @returns {ArrayBuffer}
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * wasm-bindgenãŒç”Ÿæˆã—ãŸJSã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦Wasmã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ (å®Ÿè¡Œç’°å¢ƒã‚’ä½œæˆ)
         * @param {ArrayBuffer} wasmBinary - Wasmãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿
         * @param {string} jsCode - JSã‚°ãƒ«ãƒ¼ã‚³ãƒ¼ãƒ‰
         */
        async function instantiateWasm(wasmBinary, jsCode) {
            // wasm-bindgenãŒç”Ÿæˆã—ãŸJSã‚³ãƒ¼ãƒ‰ã‚’å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
            const blob = new Blob([jsCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            
            // Wasmã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–å¾—
            const initModule = await import(url);
            
            // initSyncé–¢æ•°ã¯ã€Wasmãƒã‚¤ãƒŠãƒªã‚’ç›´æ¥å—ã‘å–ã£ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
            // (inité–¢æ•°ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ‰±ã†ãŸã‚ã“ã“ã§ã¯ä½¿ã‚ãªã„)
            return initModule.initSync(wasmBinary);
        }

        // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã®çŠ¶æ…‹è¨­å®š
        updateStatus('æº–å‚™å®Œäº†', 0, 'ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚');
    </script>
</body>
</html>
