<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Vercelã¨Renderã‚’æ´»ç”¨ã—ãŸã€ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã®Rust-to-Wasmã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã€‚">
    <meta name="keywords" content="WebAssembly, Wasm, Rust, Vercel, Render, Flask, ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©">
    <meta name="author" content="ã‚«ã‚«ã‚ªãƒãƒ¡ / Gemini programmingéšŠ">
    <meta property="og:title" content="Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© ãƒ—ãƒ­ã‚­ã‚·ã‚·ã‚¹ãƒ†ãƒ ">
    <meta property="og:description" content="ã‚ãªãŸã®Rustã‚³ãƒ¼ãƒ‰ã‚’VercelçµŒç”±ã§Renderã‚µãƒ¼ãƒãƒ¼ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã›ã¾ã™ã€‚">
    <meta property="og:image" content="https://kakaomames.github.io/rei/logo.png">
    <title>Wasm ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© ãƒ—ãƒ­ã‚­ã‚·</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        textarea { width: 100%; max-width: 800px; font-family: monospace; }
    </style>
</head>
<body>
    <h1>ğŸš€ Wasm ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© (Vercel Proxy)</h1>
    
    <textarea id="code-input" rows="20" placeholder="// Rustã‚³ãƒ¼ãƒ‰ã‚’ã“ã“ã«å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: use wasm_bindgen::prelude::*; ... )"></textarea>
    <br>
    
    <button id="compile-button" onclick="startCompilation()">Wasmã«ã™ã‚‹ï¼ãƒœã‚¿ãƒ³</button>
    <br>
    
    <hr>
    
    <h2>ğŸ“Š å¤‰æ›é€²æ—</h2>
    <p>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="status-message">å¾…æ©Ÿä¸­...</span></p>
    <p>é€²æ—: <span id="progress-percent">0%</span></p>
    <progress id="progress-bar" value="0" max="100"></progress>
    <br>
    
    <button id="download-button" style="display: none;" onclick="downloadWasm()">Wasmã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (ZIP)</button>
    
    <script>
        // ğŸš¨ Vercelã®ãƒ«ãƒ¼ãƒˆã«ãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚Œã‚‹ãŸã‚ã€APIãƒ«ãƒ¼ãƒˆã¯ç›¸å¯¾ãƒ‘ã‚¹ã‚’ä½¿ç”¨
        const API_BASE_URL = "/api"; 
        let currentTaskId = null;
        let pollingInterval = null;

        function updateUI(status, message, progress) {
            progress = Math.max(0, progress); // è² ã®æ•°ã‚’0ã«æˆ»ã™ï¼ˆã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã¯-1ï¼‰
            
            document.getElementById('status-message').textContent = message;
            document.getElementById('progress-percent').textContent = progress + '%';
            document.getElementById('progress-bar').value = progress;

            if (progress === 100) {
                document.getElementById('download-button').style.display = 'block';
                document.getElementById('compile-button').disabled = false;
                clearInterval(pollingInterval);
            } else if (progress < 100 && progress >= 0) {
                document.getElementById('download-button').style.display = 'none';
                document.getElementById('compile-button').disabled = true;
            } else if (status === 'error' || progress < 0) { // ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹
                document.getElementById('download-button').style.display = 'none';
                document.getElementById('compile-button').disabled = false;
                clearInterval(pollingInterval);
                alert(`ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼: ${message}`);
            }
        }

        async function checkStatus() {
            if (!currentTaskId) return;

            try {
                // Vercelãƒ—ãƒ­ã‚­ã‚·ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ãƒãƒ¼ãƒªãƒ³ã‚°
                const response = await fetch(`${API_BASE_URL}/status?id=${currentTaskId}`);
                
                const statusData = await response.json();

                if (response.status === 404 && statusData.message) {
                    // ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯å‰Šé™¤æ¸ˆã¿
                    updateUI('error', statusData.message, -1);
                    return;
                }
                
                if (statusData.status === 'error') {
                    updateUI('error', statusData.message, -1);
                    return;
                }
                
                updateUI(statusData.status, statusData.message, statusData.progress);

            } catch (error) {
                console.error("Polling error:", error);
                updateUI('error', 'Vercelãƒ—ãƒ­ã‚­ã‚·ã¨ã®é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', -1);
                clearInterval(pollingInterval);
            }
        }

        async function startCompilation() {
            const code = document.getElementById('code-input').value;
            
            // æ—¢å­˜ã®ãƒãƒ¼ãƒªãƒ³ã‚°ãŒã‚ã‚Œã°åœæ­¢
            if (pollingInterval) clearInterval(pollingInterval);
            
            updateUI('processing', 'ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é–‹å§‹...', 10);
            document.getElementById('compile-button').disabled = true;

            try {
                // Vercelãƒ—ãƒ­ã‚­ã‚·ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ã‚³ãƒ¼ãƒ‰ã‚’POST
                const response = await fetch(`${API_BASE_URL}/compile`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: code })
                });

                const result = await response.json();

                if (response.ok && result.status === 'success') {
                    currentTaskId = result.task_id;
                    
                    // 2ç§’ã”ã¨ã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°
                    pollingInterval = setInterval(checkStatus, 2000); 

                } else {
                    // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
                    updateUI('error', result.message || 'ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', -1);
                }

            } catch (error) {
                console.error("Fetch error:", error);
                updateUI('error', 'Vercelãƒ—ãƒ­ã‚­ã‚·ã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚', -1);
            }
        }

        function downloadWasm() {
            if (currentTaskId) {
                // Vercelãƒ—ãƒ­ã‚­ã‚·ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
                window.location.href = `${API_BASE_URL}/download/${currentTaskId}`;
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹å¾Œã€UIã‚’ãƒªã‚»ãƒƒãƒˆ
                updateUI('waiting', 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ã€‚æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’å¾…æ©Ÿä¸­...', 0);
                document.getElementById('download-button').style.display = 'none';
            }
        }

        // åˆæœŸãƒ†ã‚¹ãƒˆç”¨ã‚³ãƒ¼ãƒ‰ (ãƒ†ã‚¹ãƒˆæ™‚ã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’è§£é™¤)
        /*
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('code-input').value = `
                use wasm_bindgen::prelude::*;
                #[wasm_bindgen]
                extern "C" {
                    #[wasm_bindgen(js_namespace = console)]
                    fn log(s: &str);
                }
                #[wasm_bindgen]
                pub fn greet() {
                    log("Hello from Wasm via Vercel Proxy!");
                }
            `;
        });
        */
    </script>
</body>
</html>
